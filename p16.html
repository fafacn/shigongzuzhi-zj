<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¢åœºæ®µæ¦‚å†µ (K26+700~K27+900) - p16</title>
    <style>
        /* --- 1. æ ¸å¿ƒé…è‰²ä¸åŸºç¡€è®¾ç½® --- */
        :root {
            --crcc-blue: #003366;
            --crcc-light-blue: #f0f7ff;
            --crcc-red: #E60012;
            --fill-color: #48bb78;  /* å¡«æ–¹ç»¿ */
            --cut-color: #f56565;   /* æŒ–æ–¹çº¢ */
            --ground-line: #4a5568;
            --design-line: #003366;
            --pond-color: #4299e1;
            --text-main: #1a202c;
            --bg-grad: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            height: 100vh; width: 100vw; overflow: hidden;
            background: var(--bg-grad);
            display: flex; justify-content: center; align-items: center;
            color: var(--text-main);
        }

        /* --- 2. ä¸»å®¹å™¨ --- */
        .container {
            width: 96vw; height: 94vh;
            display: flex; flex-direction: column;
            padding: 25px;
            background: rgba(255,255,255,0.85);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.6);
            position: relative;
        }

        /* --- 3. æ ‡é¢˜åŒº --- */
        .header-section {
            flex: 0 0 auto;
            border-bottom: 2px solid rgba(0, 51, 102, 0.1);
            padding-bottom: 10px; margin-bottom: 15px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        h2 { font-size: 2.0rem; color: var(--crcc-blue); display: flex; align-items: center; gap: 15px; margin: 0; }
        h2::before { content:''; width: 8px; height: 32px; background: var(--crcc-red); display: block; }
        .subtitle { font-size: 1rem; color: #666; font-weight: normal; }
        
        .legend-box {
            display: flex; gap: 15px; font-size: 0.85rem; color: #555;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 12px; height: 12px; border-radius: 2px; }

        /* --- 4. ç»˜å›¾åŒºåŸŸå¸ƒå±€ --- */
        .charts-wrapper {
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
            position: relative;
            /* ä¿®æ”¹ç‚¹1: å¢åŠ åº•éƒ¨å†…è¾¹è·ï¼Œç»™æ‚¬æµ®æŒ‰é’®ç•™å‡ºç©ºé—´ï¼Œè¿«ä½¿å›¾è¡¨å†…å®¹ä¸Šç§» */
            padding-bottom: 60px; 
        }

        .chart-pane {
            background: #fff; border: 1px solid #e2e8f0; border-radius: 8px;
            position: relative; overflow: hidden;
            cursor: crosshair;
        }
        
        #profile-chart { flex: 3; } 
        #volume-chart { flex: 2; }

        .pane-label {
            position: absolute; top: 10px; left: 80px; 
            background: rgba(255,255,255,0.9); padding: 4px 12px;
            border-radius: 4px; border: 1px solid #cbd5e0;
            font-size: 0.85rem; font-weight: bold; color: var(--crcc-blue);
            z-index: 10; pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        /* SVG æ ·å¼ */
        svg { width: 100%; height: 100%; display: block; }
        .grid-line { stroke: #e2e8f0; stroke-width: 1; stroke-dasharray: 4; }
        .axis-text { font-size: 10px; fill: #718096; }
        
        /* äº¤äº’æ¸¸æ ‡ */
        .cursor-line { stroke: var(--crcc-blue); stroke-width: 1; stroke-dasharray: 4; pointer-events: none; opacity: 0;}
        .cursor-bubble {
            position: absolute; display: none;
            background: rgba(0, 51, 102, 0.95); color: white;
            padding: 10px; border-radius: 6px; font-size: 12px;
            pointer-events: none; z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            /* è¾¹æ¡†æ ·å¼ä¼šåœ¨JSä¸­åŠ¨æ€åˆ‡æ¢ */
            line-height: 1.6; white-space: nowrap;
        }

        /* --- 5. å¯¼èˆªæŒ‰é’® --- */
        .nav-btn {
            position: fixed; bottom: 30px; padding: 10px 25px;
            background: var(--crcc-blue); color: white;
            border-radius: 30px; text-decoration: none; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); transition: 0.3s; z-index: 200;
            font-size: 0.9rem;
        }
        .nav-btn:hover { background: var(--crcc-red); }
        .prev-btn { right: 150px; background: white; color: var(--crcc-blue); border: 1px solid var(--crcc-blue); }
        .prev-btn:hover { background: var(--crcc-red); color: white; border-color: var(--crcc-red); }
        .next-btn { right: 30px; }

    </style>
</head>
<body>

<div class="container">
    <div class="header-section">
        <div>
            <h2>æ¢åœºæ®µæ¦‚å†µ (K26+700 ~ K27+900)</h2>
            <div class="subtitle">å…¨é•¿ 1200m | å« 2åº§å¤§æ¡¥/å¤©æ¡¥ã€10åº§æ¶µæ´ | æ¶‰åŠ 3å¤„é±¼å¡˜è½¯åŸºå¤„ç†</div>
        </div>
        <div class="legend-box">
            <div class="legend-item"><div class="dot" style="background:var(--design-line)"></div>è®¾è®¡é«˜ç¨‹</div>
            <div class="legend-item"><div class="dot" style="background:var(--ground-line)"></div>åœ°é¢é«˜ç¨‹</div>
            <div class="legend-item"><div class="dot" style="background:var(--cut-color)"></div>æŒ–æ–¹(å‘ä¸Š)</div>
            <div class="legend-item"><div class="dot" style="background:var(--fill-color)"></div>å¡«æ–¹(å‘ä¸‹)</div>
            <div class="legend-item"><div class="dot" style="background:var(--pond-color)"></div>é±¼å¡˜å¤„ç†</div>
        </div>
    </div>

    <div class="charts-wrapper">
        <!-- ä¸Šéƒ¨ï¼šçºµæ–­é¢ -->
        <div class="chart-pane" id="profile-chart">
            <div class="pane-label">çºµæ–­é¢è®¾è®¡ä¸ç»“æ„ç‰©åˆ†å¸ƒ</div>
            <svg id="svg-profile"></svg>
        </div>
        
        <!-- ä¸‹éƒ¨ï¼šå·¥ç¨‹é‡ -->
        <div class="chart-pane" id="volume-chart">
            <div class="pane-label">åˆ†æ®µåœŸçŸ³æ–¹å·¥ç¨‹é‡ (mÂ³)</div>
            <svg id="svg-volume"></svg>
        </div>

        <!-- æ‚¬æµ®æç¤ºæ¡† -->
        <div id="tooltip" class="cursor-bubble"></div>
    </div>
</div>

<!-- å¯¼èˆªæŒ‰é’® -->
<a href="p15.html" class="nav-btn prev-btn">ä¸Šä¸€é¡µ</a>
<a href="p17.html" class="nav-btn next-btn">ä¸‹ä¸€é¡µ</a>

<script>
    // --- 1. æ•°æ®é…ç½® ---
    const CONFIG = {
        range: [26700, 27900], // K26+700 ~ K27+900
        length: 1200,
        elevRange: [25, 60],
        volMax: 6000,
        padding: { left: 60, right: 40, top: 40, bottom: 30 }
    };

    // æ¨¡æ‹Ÿæ•°æ®
    const DATA = {
        ground: [
            [26700, 32], [26750, 31], [26800, 33], [26850, 35], 
            [26900, 38], [27000, 42], [27100, 45], [27200, 49], 
            [27300, 47], [27400, 42], [27500, 41], [27600, 44], 
            [27700, 50], [27800, 54], [27850, 48], [27900, 42]
        ],
        design: [
            [26700, 38.0], [26800, 38.3], [26900, 38.6], 
            [27000, 39.5], [27200, 40.8], [27400, 41.2], 
            [27600, 41.5], [27800, 40.0], [27900, 36.5]
        ],
        structures: [
            { m: 26745, type: 'culvert', name: 'æ¶µæ´' },
            { m: 26847, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27038, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27163, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27220, type: 'bridge', name: 'K27+220 2x35mç«‹äº¤' },
            { m: 27264, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27360, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27511, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27571, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27741, type: 'bridge', name: 'K27+741 2x35mç«‹äº¤' },
            { m: 27757, type: 'culvert', name: 'æ¶µæ´' },
            { m: 27855, type: 'culvert', name: 'æ¶µæ´' }
        ],
        ponds: [
            { start: 26740, end: 26900, label: "é±¼å¡˜1" },
            { start: 27120, end: 27280, label: "é±¼å¡˜2" },
            { start: 27350, end: 27440, label: "é±¼å¡˜3" }
        ],
        volumes: [] 
    };

    // æ•°æ®ç”Ÿæˆ
    for (let m = CONFIG.range[0]; m <= CONFIG.range[1]; m += 20) {
        const hG = getElev(m, DATA.ground);
        const hD = getElev(m, DATA.design);
        const diff = hD - hG;
        let cut = 0, fill = 0;
        if (diff > 0) fill = diff * 20 * 15;
        else cut = Math.abs(diff) * 20 * 18;
        
        fill = fill > 0 ? fill + Math.random()*200 : 0;
        cut = cut > 0 ? cut + Math.random()*200 : 0;
        DATA.volumes.push({ m: m, cut: cut, fill: fill });
    }

    function getElev(m, points) {
        if (m <= points[0][0]) return points[0][1];
        if (m >= points[points.length-1][0]) return points[points.length-1][1];
        for (let i = 0; i < points.length - 1; i++) {
            if (m >= points[i][0] && m <= points[i+1][0]) {
                const ratio = (m - points[i][0]) / (points[i+1][0] - points[i][0]);
                return points[i][1] + ratio * (points[i+1][1] - points[i][1]);
            }
        }
        return 0;
    }

    let scaleX, scaleY_Prof;

    function initScales(wP, hP) {
        scaleX = (m) => CONFIG.padding.left + (m - CONFIG.range[0]) / CONFIG.length * (wP - CONFIG.padding.left - CONFIG.padding.right);
        scaleY_Prof = (e) => hP - CONFIG.padding.bottom - (e - CONFIG.elevRange[0]) / (CONFIG.elevRange[1] - CONFIG.elevRange[0]) * (hP - CONFIG.padding.top - CONFIG.padding.bottom);
    }

    function render() {
        const svgP = document.getElementById('svg-profile');
        const svgV = document.getElementById('svg-volume');
        svgP.innerHTML = ''; svgV.innerHTML = '';

        const wP = svgP.clientWidth, hP = svgP.clientHeight;
        const wV = svgV.clientWidth, hV = svgV.clientHeight;

        initScales(wP, hP);

        // 1. Profile Chart
        DATA.ponds.forEach(pond => {
            const x1 = scaleX(pond.start);
            const x2 = scaleX(pond.end);
            const y = hP - CONFIG.padding.bottom;
            svgP.appendChild(createSVG('rect', {
                x: x1, y: y - 15, width: x2 - x1, height: 15,
                fill: 'url(#pondPattern)', stroke: 'var(--pond-color)', 'stroke-width': 1, opacity: 0.6
            }));
            const label = createSVG('text', {
                x: (x1+x2)/2, y: y - 4, 'text-anchor': 'middle', 'font-size': '10', fill: '#004d99', 'font-weight': 'bold'
            });
            label.textContent = pond.label;
            svgP.appendChild(label);
        });

        let step = 2;
        for (let m = CONFIG.range[0]; m <= CONFIG.range[1]; m += step) {
            const x = scaleX(m);
            const yG = scaleY_Prof(getElev(m, DATA.ground));
            const yD = scaleY_Prof(getElev(m, DATA.design));
            const isCut = yG < yD; 
            const strokeColor = isCut ? 'var(--cut-color)' : 'var(--fill-color)';
            svgP.appendChild(createSVG('line', {
                x1: x, y1: yG, x2: x, y2: yD,
                stroke: strokeColor, 'stroke-width': step, opacity: 0.3
            }));
        }

        const drawLine = (data, color, width, dash='') => {
            let pathD = `M ${scaleX(CONFIG.range[0])} ${scaleY_Prof(getElev(CONFIG.range[0], data))}`;
            for(let m = CONFIG.range[0]+10; m<=CONFIG.range[1]; m+=10) {
                 pathD += ` L ${scaleX(m)} ${scaleY_Prof(getElev(m, data))}`;
            }
            svgP.appendChild(createSVG('path', { d: pathD, fill: 'none', stroke: color, 'stroke-width': width, 'stroke-dasharray': dash }));
        };
        drawLine(DATA.ground, 'var(--ground-line)', 2, '5,3');
        drawLine(DATA.design, 'var(--design-line)', 3);

        DATA.structures.forEach(st => {
            const x = scaleX(st.m);
            const yBot = hP - CONFIG.padding.bottom;
            const yTop = scaleY_Prof(getElev(st.m, DATA.design));
            const color = st.type === 'bridge' ? '#d53f8c' : '#805ad5';
            
            svgP.appendChild(createSVG('line', { x1: x, y1: yTop, x2: x, y2: yBot, stroke: color, 'stroke-width': st.type==='bridge'?2:1, 'stroke-dasharray': '2,2' }));
            
            const iconY = yBot - 60;
            if(st.type === 'bridge') {
                svgP.appendChild(createSVG('rect', { x: x-10, y: iconY, width: 20, height: 10, fill: color, rx:2 }));
            } else {
                svgP.appendChild(createSVG('circle', { cx: x, cy: iconY+5, r: 4, fill: 'white', stroke: color, 'stroke-width': 2 }));
            }
            svgP.appendChild(createSVG('text', { x: x, y: iconY - 5, 'text-anchor': 'middle', 'font-size': '10', fill: color, 'font-weight': 'bold' })).textContent = st.name;
        });

        drawAxisProfile(svgP, wP, hP);

        // 2. Volume Chart
        const vChartHeight = hV - CONFIG.padding.top - CONFIG.padding.bottom;
        const yZero = CONFIG.padding.top + vChartHeight / 2;
        const scaleVolHeight = (v) => (v / CONFIG.volMax) * (vChartHeight / 2);

        svgV.appendChild(createSVG('line', {
            x1: CONFIG.padding.left, y1: yZero, x2: wV - CONFIG.padding.right, y2: yZero,
            stroke: '#4a5568', 'stroke-width': 2
        }));

        DATA.volumes.forEach(v => {
            const x = scaleX(v.m);
            const barW = (wP - CONFIG.padding.left - CONFIG.padding.right) / (CONFIG.length / 20) * 0.6; 
            
            if (v.cut > 10) {
                const h = scaleVolHeight(v.cut);
                svgV.appendChild(createSVG('rect', {
                    x: x - barW/2, y: yZero - h, width: barW, height: h,
                    fill: 'var(--cut-color)', opacity: 0.8
                }));
            }
            if (v.fill > 10) {
                const h = scaleVolHeight(v.fill);
                svgV.appendChild(createSVG('rect', {
                    x: x - barW/2, y: yZero, width: barW, height: h,
                    fill: 'var(--fill-color)', opacity: 0.8
                }));
            }
        });
        
        DATA.structures.forEach(st => {
            const x = scaleX(st.m);
            svgV.appendChild(createSVG('line', { x1: x, y1: CONFIG.padding.top, x2: x, y2: hV - CONFIG.padding.bottom, stroke: '#cbd5e0', 'stroke-dasharray': '2,2' }));
             svgV.appendChild(createSVG('text', { x: x, y: hV - 10, 'text-anchor': 'middle', 'font-size': '9', fill: '#718096' })).textContent = st.type === 'bridge' ? 'å¤©æ¡¥' : 'æ¶µ';
        });

        drawAxisVolume(svgV, wV, hV, yZero, vChartHeight);

        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        defs.innerHTML = `
            <pattern id="pondPattern" patternUnits="userSpaceOnUse" width="8" height="8" patternTransform="rotate(45)">
                <line x1="0" y="0" x2="0" y2="8" stroke="#4299e1" stroke-width="2" />
            </pattern>
        `;
        svgP.prepend(defs);

        const cursorP = createSVG('line', { class: 'cursor-line', y1: CONFIG.padding.top, y2: hP-CONFIG.padding.bottom });
        const cursorV = createSVG('line', { class: 'cursor-line', y1: CONFIG.padding.top, y2: hV-CONFIG.padding.bottom });
        svgP.appendChild(cursorP);
        svgV.appendChild(cursorV);

        setupInteraction(svgP, svgV, wP);
    }

    function drawAxisProfile(svg, w, h) {
        for(let v = CONFIG.elevRange[0]; v <= CONFIG.elevRange[1]; v += 5) {
            const y = scaleY_Prof(v);
            svg.appendChild(createSVG('text', { x: CONFIG.padding.left - 5, y: y+4, 'text-anchor': 'end', 'font-size': '10', fill: '#718096' })).textContent = v;
            svg.appendChild(createSVG('line', { x1: CONFIG.padding.left, y1: y, x2: w - CONFIG.padding.right, y2: y, class: 'grid-line' }));
        }
        svg.appendChild(createSVG('text', { x: 10, y: 20, 'font-size': '11', 'font-weight':'bold', fill:'#4a5568' })).textContent = 'é«˜ç¨‹';
        svg.appendChild(createSVG('text', { x: 10, y: 35, 'font-size': '10', fill:'#718096' })).textContent = '(m)';
        
        const axisY = h - CONFIG.padding.bottom;
        svg.appendChild(createSVG('line', { x1: CONFIG.padding.left, y1: axisY, x2: w - CONFIG.padding.right, y2: axisY, stroke: '#4a5568', 'stroke-width': 1 }));
        for(let m = CONFIG.range[0]; m <= CONFIG.range[1]; m += 100) {
            const x = scaleX(m);
            svg.appendChild(createSVG('line', { x1: x, y1: axisY, x2: x, y2: axisY+5, stroke: '#4a5568' }));
            svg.appendChild(createSVG('text', { x: x, y: axisY+18, 'text-anchor': 'middle', 'font-size': '10', fill: '#4a5568' })).textContent = `K${Math.floor(m/1000)}+${(m%1000).toString().padStart(3,'0')}`;
        }
    }

    function drawAxisVolume(svg, w, h, yZero, chartH) {
        const step = 3000;
        for(let v = step; v <= CONFIG.volMax; v += step) {
            const y = yZero - (v / CONFIG.volMax) * (chartH / 2);
            svg.appendChild(createSVG('text', { x: CONFIG.padding.left - 5, y: y+4, 'text-anchor': 'end', 'font-size': '10', fill: '#718096' })).textContent = v;
            svg.appendChild(createSVG('line', { x1: CONFIG.padding.left, y1: y, x2: w - CONFIG.padding.right, y2: y, class: 'grid-line' }));
        }
        for(let v = step; v <= CONFIG.volMax; v += step) {
            const y = yZero + (v / CONFIG.volMax) * (chartH / 2);
            svg.appendChild(createSVG('text', { x: CONFIG.padding.left - 5, y: y+4, 'text-anchor': 'end', 'font-size': '10', fill: '#718096' })).textContent = v;
            svg.appendChild(createSVG('line', { x1: CONFIG.padding.left, y1: y, x2: w - CONFIG.padding.right, y2: y, class: 'grid-line' }));
        }
        svg.appendChild(createSVG('text', { x: CONFIG.padding.left - 5, y: yZero+4, 'text-anchor': 'end', 'font-size': '10', fill: '#4a5568' })).textContent = "0";

        svg.appendChild(createSVG('text', { x: 10, y: 20, 'font-size': '11', 'font-weight':'bold', fill:'#4a5568' })).textContent = 'å·¥ç¨‹é‡';
        svg.appendChild(createSVG('text', { x: 10, y: 35, 'font-size': '10', fill:'#718096' })).textContent = '(mÂ³)';

        const axisY = h - CONFIG.padding.bottom;
        svg.appendChild(createSVG('line', { x1: CONFIG.padding.left, y1: axisY, x2: w - CONFIG.padding.right, y2: axisY, stroke: '#e2e8f0' })); 
        for(let m = CONFIG.range[0]; m <= CONFIG.range[1]; m += 100) {
            const x = scaleX(m);
            svg.appendChild(createSVG('text', { x: x, y: axisY+18, 'text-anchor': 'middle', 'font-size': '10', fill: '#4a5568' })).textContent = `K${Math.floor(m/1000)}+${(m%1000).toString().padStart(3,'0')}`;
        }
    }

    function createSVG(tag, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (let k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    }

    function setupInteraction(svgP, svgV, w) {
        const tooltip = document.getElementById('tooltip');
        const cursors = document.querySelectorAll('.cursor-line');

        const update = (e) => {
            const rect = svgP.getBoundingClientRect();
            let x = e.clientX - rect.left;
            x = Math.max(CONFIG.padding.left, Math.min(x, w - CONFIG.padding.right));
            
            const ratio = (x - CONFIG.padding.left) / (w - CONFIG.padding.left - CONFIG.padding.right);
            const m = CONFIG.range[0] + ratio * CONFIG.length;
            
            cursors.forEach(c => { c.setAttribute('x1', x); c.setAttribute('x2', x); c.style.opacity = 1; });

            const hG = getElev(m, DATA.ground).toFixed(2);
            const hD = getElev(m, DATA.design).toFixed(2);
            const hDiff = (hD - hG).toFixed(2);
            
            const volIdx = Math.round((m - CONFIG.range[0]) / 20);
            const volData = DATA.volumes[volIdx] || { cut:0, fill:0 };

            const nearbyStruct = DATA.structures.find(s => Math.abs(s.m - m) < 10);
            const structText = nearbyStruct ? `<br><span style="color:#d53f8c">â˜… ${nearbyStruct.name}</span>` : '';
            const inPond = DATA.ponds.find(p => m >= p.start && m <= p.end);
            const pondText = inPond ? `<br><span style="color:#4299e1">ğŸ’§ ${inPond.label}å¤„ç†æ®µ</span>` : '';

            const type = parseFloat(hDiff) > 0 ? "å¡«æ–¹" : "æŒ–æ–¹";
            const color = parseFloat(hDiff) > 0 ? "var(--fill-color)" : "var(--cut-color)";

            tooltip.style.display = 'block';
            
            // --- ä¿®æ”¹ç‚¹2: æ™ºèƒ½ä½ç½®åˆ¤æ–­ (Tooltip Flip) ---
            const windowWidth = window.innerWidth;
            const tooltipWidth = 240; // é¢„ä¼°æ‚¬æµ®çª—å®½åº¦
            
            if (e.clientX + tooltipWidth > windowWidth - 20) {
                // å¦‚æœé å³ï¼Œæ˜¾ç¤ºåœ¨é¼ æ ‡å·¦ä¾§
                tooltip.style.left = (e.clientX - tooltipWidth - 20) + 'px';
                tooltip.style.borderLeft = 'none';
                tooltip.style.borderRight = `3px solid ${color}`;
            } else {
                // é»˜è®¤æ˜¾ç¤ºåœ¨é¼ æ ‡å³ä¾§
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.borderRight = 'none';
                tooltip.style.borderLeft = `3px solid ${color}`;
            }

            tooltip.style.top = (e.clientY + 15) + 'px';
            // ----------------------------------------

            tooltip.innerHTML = `
                <strong>é‡Œç¨‹: K${Math.floor(m/1000)}+${(m%1000).toFixed(0).padStart(3,'0')}</strong>
                ${structText}
                ${pondText}
                <hr style="margin:5px 0; border-color:rgba(255,255,255,0.3)">
                è®¾è®¡é«˜ç¨‹: ${hD} m<br>
                åœ°é¢é«˜ç¨‹: ${hG} m<br>
                <span style="color:${color}; font-weight:bold">${type}: ${Math.abs(hDiff)} m</span><br>
                <span style="font-size:11px; color:#ccc">æœ¬æ®µ(20m)å·¥ç¨‹é‡:</span><br>
                <span style="color:var(--cut-color)">æŒ–: ${volData.cut.toFixed(0)} mÂ³</span> | 
                <span style="color:var(--fill-color)">å¡«: ${volData.fill.toFixed(0)} mÂ³</span>
            `;
        };

        const hide = () => { tooltip.style.display = 'none'; cursors.forEach(c => c.style.opacity = 0); };

        [svgP, svgV].forEach(el => { el.addEventListener('mousemove', update); el.addEventListener('mouseleave', hide); });
    }

    window.onload = render;
    window.onresize = render;

</script>
</body>
</html>